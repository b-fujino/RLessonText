---
title: "データハンドリング"
author: "藤野秀則,"
date: 
  初稿日:2024-05-16
  更新日:`r Sys.Date()`
output:
  html_document: 
    toc: true
    toc_depth: 4
    toc_float: true
    number_section: true
    fig_width: 8
    css: style.css
  # html_notebook:
  #   toc: true
  #   toc_depth: 3
  #   toc_float: true
  #   number_section: true
editor_options:
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


以下では具体的な例を示すためにRに最初から入っているデモ用データの`iris`を用いる．
irisデータはアイリス（菖蒲）のがく(Sepal)と花びら(Petal)の長さ(length)と幅(width)の実測データが3つのアイリスの種類（`Setosa`, `vergicolor`, `virginica`）ごとに50点ずつ格納されている．
内容を確認するために，`summary()`関数と`head()`関数（データフレームの冒頭データを出力させる関数)を実行してみた．

```{r }
data_iris <- iris #irisデータを呼び出してdというオブジェクトに格納
summary(data_iris)
head(data_iris)
```

列名が英語のままだと分かりにくいので，日本語に翻訳した名前に置き換える(-\>[参考](./RText_03_BasicUsage2.html#列名へのアクセスと変更))．以下はそのためのコード．
```{R}
colnames(data_iris) <-  c("がく長","がく幅","花びら長","花びら幅","種類")
head(data_iris)
```


# 抽出


グループ分け変数を持ったデータを処理するときに，ある特定のグループのデータだけを抜き出したいということはよくある．
そうした「データの抽出」を行うための関数として`tidyverse`パッケージに`filter()`関数が設けられている．利用するためにはT**ools-\>install.packagesで`tidyverse`パッケージをインストールしたうえで，スクリプト上で`library(tidyverse)`と入力してパッケージを読み込む必要がある**．

`filter()`関数の利用法は，第1引数に元のデータを与え，第2引数に検索条件を与える．検索条件の書式のパターンは以下の通り．

|書式|動作|
|:--|:----------|
|元データ\$列名==Key|列名で指定した列の値がKeyと一致しているものを抽出．「=」を重ねる点がポイント．|
|元データ\$列名>Key|列名で指定した列の値がKeyよりも大きいものを抽出|
|元データ\$列名>=Key|列名で指定した列の値がKeyと等しいかKeyよりも大きいものを抽出|
|元データ\$列名<Key|列名で指定した列の値がKeyよりも小さいものを抽出|
|元データ\$列名<=Key|列名で指定した列の値がKeyと等しいかKeyよりも小さいものを抽出|




```{r}
library(tidyverse)

summary(data_iris)
res<- filter(data_iris, 種類=="virginica")
summary(res)
res <- filter(data_iris, がく長<=5)
summary(res)
res <- filter(data_iris, がく長>=6)
summary(res)
```

条件は複数並べることもできる．`|`は複数の条件のいずれかにマッチすれば抽出される．`&`は複数条件の全てにマッチするものが抽出される．
それぞれ以下に示す．
```{r}
res <- filter(data_iris, がく長>=6 | 花びら長>1.5) # がく長が6以上「または」花びら長が1.5より大きいもの
summary(res)
res <- filter(data_iris, がく長>=6 & 花びら長>1.5) # がく長が6以上「かつ」花びら長が1.5より大きいもの
summary(res)
res <- filter(data_iris, がく長>=5 & がく長<6.5) # 5<=がく長<6.5
summary(res)
res <- filter(data_iris, がく長<5 | がく長>=6.5) # がく長<5, 6.5<=学長
summary(res)

```
抽出したデータのある列だけが必要だという場合には，抽出したデータを収めたオブジェクトにに`$`や`[]`をつけて指定すればよい．以下では内容を確認するため，`head()`関数を使って最初の数行だけを表示させている．

```{r}
res <- filter(data_iris, がく長>=6 | 花びら長>1.5)
res<- res$花びら長
head(res)

res <- filter(data_iris, がく長>=6 | 花びら長>1.5)
res<- res["花びら長"]
head(res)



#次のように関数に対して直接[]や$を書くこともできる
res2 <- filter(data_iris, がく長>=6 | 花びら長>1.5)$花びら長
head(res2)

res2 <- filter(data_iris, がく長>=6 | 花びら長>1.5)["花びら長"]
head(res2)

#複数の列を取り出す場合には[c()]を使う
res3 <- filter(data_iris, がく長>=6 | 花びら長>1.5)[c("花びら長","花びら幅")]
head(res3)

```
`$`と`[]`とで出力が違うのは[こちら](./RText_03_BasicUsage2.html#列へのアクセス)で説明したように，`$`は指定した列をベクトルとして取り出すのに対して，`[]`は指定した列だけで構成されるデータフレームとして取り出されるためである．

<!--以下，2024/5/16　追記 -->

# 数値の置換
数値の置換には`ifelse()`関数を応用する．`ifelse()`関数は，第1引数に条件を記述し（条件の記述方法は検索と同じ），第2引数には条件にマッチした場合に置き換える値，第3引数にはマッチしなかった場合に置き換える値を記載する（Excelの`if()`関数と同じ引数構造である）．`ifelse()`関数の実行結果として最終的に返ってくるのは，そうした置き換えが行われたベクトルとなる．あくまでベクトルが返ってくるだけなので，実際に置き換えをデータに反映させるためには，元のデータの元の列に返ってきたベクトルを代入するなり，元のデータに新しい列を作ってベクトルを代入するなりする必要がある．

:::ref
「値」と記載しているが，コンピュータの用語として「値」という場合には，数値だけでなく文字列も含められていることは覚えておこう．数値だけをいう場合には「数値」，文字列だけを言う場合には「文字列」とはっきりと言わなければならない．
:::

以下の例ではがく長が平均以上なら1，未満なら0を割り当てた新しい変数`bがく長`を作成している．


```{R}
data_iris2 <- data_iris 
data_iris2$bがく長 <- ifelse(data_iris2$がく長 >= mean(data_iris2$がく長), 1, 0)
print(data_iris2$bがく長)
```

ついでに`as.factor()`を用いて要因型に変換をしてみた．
```{r}
data_iris2$bがく長 <- as.factor(data_iris2$bがく長)
summary(data_iris2)
```

## ifelse()の入れ子
`ifelse()`関数は入れ子にすることもできる．すなわち，

```{}
ifelse(<<条件>>, <<条件が真の場合の処理>>, 
    ifelse(<<条件2>>, <<条件2が真の場合の処理>>, <<条件2が偽の場合の処理)
    )
```

という書き方ができる．

以下の例では，入れ子を用いてがく長を以下の4段階に分けてたものを`bがく長`に格納している．

- 平均-標準偏差未満には0
- 平均-標準偏差以上，平均未満ならば1
- 平均以上，平均＋標準偏差未満ならば2
- 平均＋標準偏差以上ならば3


```{R}
data_iris2 <- data_iris
M <- mean(data_iris2$がく長)
SD <-sd(data_iris2$がく長)
data_iris2$bがく長 <- ifelse(data_iris2$がく長 < M-SD,0,
                          ifelse(data_iris2$花びら長 <M,1,
                                 ifelse(data_iris2$花びら長 < M+SD,2,3)
                                )
                          )
print(data_iris2$bがく長)
data_iris2$bがく長 <- as.factor(data_iris2$bがく長)
summary(data_iris2)
```

なお，上記では分かりやすさのため，入れ子となっている箇所で改行をしているが，別に改行しなくてもよい．以下は改行せずに書いた例．上記と同じ結果を返す．

```{r}
data_iris2$bがく長 <- ifelse(data_iris2$がく長<M-SD, 0, ifelse(data_iris2$花びら長<M, 1, ifelse(data_iris2$花びら長<M+SD, 2, 3)))
print(data_iris2$bがく長)
data_iris2$bがく長 <- as.factor(data_iris2$bがく長)
summary(data_iris2)
```

:::ref
<details>
<summary>ifelse()関数の第2，第3引数</summary>
ifelse()関数は第2，第3引数はそれぞれ第1引数で指定した条件が真であった場合に返す値，偽であった場合に返す値を設定しているが，この部分に式や関数を指定しても良い．先のifelse()の入れ子はまさに関数の1つとしてのifelse()を実行している例だが，例えば，以下のようにすることもできる．
```{r}
M<-mean(data_iris2$がく長)
SD<-sd(data_iris2$がく長)
data_iris2$がく長r <- ifelse(data_iris2$がく長<M-SD, M-SD, ifelse(data_iris2$花びら長>=M+SD, M+SD, M))
print(data_iris2$がく長r)
```
この例では，がく長が平均-標準偏差未満のものは，すべて平均-標準偏差=`r M-SD`に，平均+標準偏差以上のものは，すべて平均+標準偏差=`r M+SD`に，平均-標準偏差から平均+標準偏差の間にあるものは全て平均=`r M`に置き換えられる

</details>
:::


# 文字列の置換

文字列型の列や要因型の列を置換したい場合には`ifelse()`関数を使うよりも，`recode()`関数を使うほうが簡単である．

第1引数には，変換したいベクトル，第2引数以降には，置換内容を記述していく．置換内容が指定されていないものは元の値が維持される．以下の例では，`setosa`を`セトサ`に，`versicolor`を`バーシカラー`に置換している．

```{R}
data_iris2 <- data_iris 
data_iris2$種類 <- recode(data_iris2$種類, "setosa"="セトサ", "versicolor"="バーシカラー")
print(data_iris2$種類)

```

上記の例では文字列を文字列で置換しているので，`=`の前後はすべて`""`で括っているが，数値に置換する場合には当然ながら`""`は不要である．ただし，この場合，置換内容が指定されていなかったものは`NA`として処理されるので注意が必要である．

```{R}
data_iris2 <- data_iris 
data_iris2$種類 <- recode(data_iris2$種類, "setosa"=1, "versicolor"=2) # virginicaは置換されないのでNAになる
print(data_iris2$種類)
```

```{R include=FALSE}
#元に戻す
data_iris2 <- data_iris 
data_iris2$種類 <- recode(data_iris2$種類, "setosa"=1, "versicolor"=2, "virginica"=3)
summary(data_iris2$種類)
data_iris2$種類 <- ifelse(data_iris2$種類==1,"setosa", 
                        ifelse(data_iris2$種類==2, "versicolor", 
                               ifelse(data_iris2$種類==3,"virginica", NA)
                              )
                        )

summary(data_iris2$種類)
data_iris2$種類<-as.factor(data_iris2$種類)
summary(data_iris2$種類)

```



:::ref
<details>
<summary>`ifelse()`を使った文字列置換</summary>
文字列の変換に`ifelse()`関数を使うこともできるが，列が要因型の場合には，一旦文字列型に変換してからでないと，思ったような結果とならない場合がある．例えば，以下の例では`setosa`だけを`セトサ`に置き換えたいと思って実行したのにもかかわらず，列が要因型ではなく勝手に文字列型にされ，さらに，他のもの種類名も勝手に`2`や`3`に設定されてしまっているのがわかる．
```{r results='hold'}
data_iris2 <- data_iris
data_iris2$種類 <- ifelse(data_iris2$種類=="setosa", "セトサ", data_iris2$種類 )
summary(data_iris2$種類) #サマリー表示 classがCharacter（文字列型）となっている
data_iris2$種類 #中身を確認してみる
```
意図した通りのことをしたいならば，以下のようになる．つまり，一旦，文字列型に戻した後に，`ifelse()`で置換を行ない，再度要因型に変換している．
```{r results='hold'}
data_iris2 <- data_iris
data_iris2$種類 <- as.character(data_iris2$種類) #要因型から文字列型に変換
data_iris2$種類 <- ifelse(data_iris2$種類=="setosa", "セトサ", data_iris2$種類 )
data_iris2$種類 #中身を確認してみる
summary(data_iris2$種類) #サマリー表示
data_iris2$種類 <- as.factor(data_iris2$種類) #文字列型から要因型に変換
summary(data_iris2$種類) #サマリー表示　要因型に変換したので表示が変わる
```
</details>
:::

# 欠損データの除外

実験や調査を行った際にデータの一部が欠損しているケースは多々ある．Rでは欠損データはデータフレーム上で`NA`（Not Available：利用不可能の意味）と表記されている．

関数によっては欠損データを含んでいるデータを受け付けないケースがある．例えばすでに[平均値](#平均値)で紹介したように`mean()`関数は，そのままでは欠損値を含んだデータは受け付けない．

`mean()`関数では，関数の引数で`na.rm = T`を設定しておくと関数処理の中で`NA`を除いて処理してくれるが，そもそも与えるデータそのもので`NA`を除いておくほうが望ましい．

例えば，次のようなデータを処理するケースを考えよう．これはAからFまでの6人に対して10問セットの2種類のクイズを解いてもらった時のスコアである．ただ，1つめのデータセットではDさんのデータが，2つめのデータではEさんのデータが欠損してしまっている．このスコアをもとに，どちらのデータセットが難しいデータだったのかを比べたい．そこで，それぞれの平均や標準偏差を求めてみた．欠損データを含んでいるので`na.rm=T`を設定した．さて，このやり方は正しいだろうか．


```{r}
data_iris3 <- data.frame(
  name = c("A", "B", "C", "D", "E", "F"),
  score1 = c(9,8,9,NA,6,7),
  score2 = c(8,7,8,10,NA,7)
)

mean(data_iris3$score1, na.rm=T)
sd(data_iris3$score1, na.rm=T)

mean(data_iris3$score2, na.rm=T)
sd(data_iris3$score2, na.rm=T)
```

このデータの場合，平均や標準偏差を単純比較してはまずい．理由として`score1`ではD以外のデータが使われているのに対して，`score2`ではE以外のデータが使われているからである．すなわち，それぞれを計算するときに使われたデータが異なっているからである．もしDさんがクイズがすごく得意な人であったならば，Dさんのデータが入っていない`score1`の方は，不当に低くくなってしまっているであろうし，逆にEさんがクイズが苦手な人であったならば，Eさんのデータが入っていない`score2`の方は不当に高くなっている可能性がある．

データを比較するときには，比較しようとしている項目以外で結果に影響を与えると考えられる項目（条件）は同一条件となっている，ということが大前提である．したがって，上記のようなデータを比較するときには，2種類のクイズのデータが両方ともそろっているA,B,C,Fの4人のデータだけで比較するべきである．

このように，データの一部に欠損値を含んでいるよな観測をすべて除外して，すべての変数でデータがそろっているものだけを残すには，`na.omit()`関数を用いる．
```{r}
data_iris3.naomit <- na.omit(data_iris3)
data_iris3.naomit

mean(data_iris3.naomit$score1)
sd(data_iris3.naomit$score1)
mean(data_iris3.naomit$score2)
sd(data_iris3.naomit$score2)
```

こうした欠損値は特に任意回答の項目を入れているアンケート調査では間違いなく含まれてくるし，紙でとったアンケート調査においては無回答であったり，択一回答の質問なのに勝手に2つ以上の選ぶなど不正回答をしてくるケースも多々ある．そういう場合にはデータ上は`NA`として処理すべきデータとなる．そのような形で`NA`を含んだデータではデータを読み込んだ時点で上記の通りに`na.omit()`を実施しておくとよい．

# データの整理方法（ワイド形式とロング形式）

例えば，ある中学校のあるクラス(25人)での1年間の定期テストでの数学の得点をデータとして扱う事例を考えてみよう．

人がそのようなデータを扱うときには以下のような表を作るだろう．

| 学生番号 | 前期中間 | 前期期末 | 後期中間 | 後期期末 |
|:--|:--|:--|:--|:--|
| 1          | 75            | 94          | 89             | 65           |
| 2          | 60            | 81          | 70             | 95           |
| 3          | 68            | 84          | 65             | 70           |
| 4          | 99            | 78          | 80             | 88           |
| 5          | 73            | 59          | 85             | 64           |
|・・・|・・・|・・・|・・・|・・・|・・・|
| 24         | 85            | 62          | 75             | 88           |
| 25         | 72            | 77          | 87             | 92           |
<!-- | 6          | 79            | 93          | 55             | 80           | -->
<!-- | 7          | 96            | 97          | 76             | 85           | -->
<!-- | 8          | 56            | 78          | 58             | 89           | -->
<!-- | 9          | 77            | 60          | 94             | 97           | -->
<!-- | 10         | 83            | 74          | 99             | 82           | -->
<!-- | 11         | 71            | 88          | 86             | 77           | -->
<!-- | 12         | 55            | 71          | 80             | 91           | -->
<!-- | 13         | 81            | 83          | 67             | 87           | -->
<!-- | 14         | 67            | 61          | 54             | 99           | -->
<!-- | 15         | 92            | 75          | 99             | 72           | -->
<!-- | 16         | 74            | 79          | 97             | 76           | -->
<!-- | 17         | 87            | 64          | 96             | 55           | -->
<!-- | 18         | 58            | 94          | 71             | 84           | -->
<!-- | 19         | 93            | 96          | 92             | 69           | -->
<!-- | 20         | 64            | 66          | 83             | 78           | -->
<!-- | 21         | 69            | 91          | 90             | 75           | -->
<!-- | 22         | 84            | 73          | 68             | 81           | -->
<!-- | 23         | 70            | 65          | 78             | 94           | -->


このようなデータの並べ方を**「ワイド形式」**と呼ぶ．ワイド形式は一般に人がみてわかりやすい表形式となる．
それに対して，Rで扱う表は以下のような並べ方のデータを並べている方が扱いやすい．このような並べ方を**「ロング形式」**と呼ぶ．

|データNo.| 生徒番号 | 時期     | 得点 |
|:--|:--|:--|:--|
|1| 1          | 前期中間  | 75    |
|2| 1          | 前期期末    | 94    |
|3| 1          | 後期中間 | 89    |
|4| 1          | 後期期末   | 65    |
|5| 2          | 前期中間  | 60    |
|6| 2          | 前期期末    | 81    |
|7| 2          | 後期中間 | 70    |
|8| 2          | 後期期末   | 95    |
|9| 3          | 前期中間  | 68    |
|10| 3          | 前期期末    | 84    |
|11| 3          | 後期中間 | 65    |
|12| 3          | 後期期末   | 70    |
|13| 4          | 前期中間  | 99    |
|・・・|・・・|・・・|・・・|
|92| 23         | 後期期末   | 94    |
|93| 24         | 前期中間  | 85    |
|94| 24         | 前期期末    | 62    |
|95| 24         | 後期中間 | 75    |
|96| 24         | 後期期末   | 88    |
|97| 25         | 前期中間  | 72    |
|98| 25         | 前期期末    | 77    |
|99| 25         | 後期中間 | 87    |
|100| 25         | 後期期末   | 92    |

ワイド形式では列は測定された属性変数を**属性値ごとに横に並べる**のに対して，ロング形式では属性変数はあくまで**一つの変数として1つの列にまとめられ縦方向に各属性値が記述されていく**が異なる．

また，ワイド形式の場合，例えば，数学の得点を並べた表とは国語の得点を並べた表ば別個に作成する必要がある．
一方で，ロング形式の場合，数学の得点の列，国語の得点の列，というように並べて行けばよい．

データ処理という点では，人の目からはわかりづらいがロング形式のデータの方が，**何が変数なのか**が明確に分かるため，ロング形式のデータを作る習慣を持っておこう．

## ワイド形式からロング形式への変換
`tidyverse`パッケージ（正確には`tidyr`パッケージ）ではワイド形式のデータをロング形式のデータに変換する`pivot_longer()`関数が存在している．もし提供されたデータがワイド形式であった場合には，`pivot_longer()`関数を用いればよい（もちろん，Excelで手作業で並べ変えを行っても構わない）．

pivot_longer()関数の引数は以下のとおりである．

- 第1引数：変換対象となっているワイド形式のデータフレーム
- 第2引数：`cols=`の形でワイド形式で列名になっている属性名を与える．
- 第3引数：`names_to=`で第2引数で指定した属性名を収めた列に与える属性変数の名を与える．
- 第4引数：`values_to=`でワイド形式での各値そのものの変数名を与える．

以下に例を示す．

```{R}
# ワイド形式のデータフレームを作成
wide_data <- data.frame(
  id = 1:4,
  性別=c("男性","女性","男性","女性"),
  time1 = c(10, 20, 30, 40),
  time2 = c(50, 60, 70, 80),
  time3 = c(90, 100, 110,120)
)

# ワイド形式のデータを表示
print(wide_data)

# ロング形式に変換
long_data <- pivot_longer(
  wide_data,
  cols=c("time1","time2","time3"),# cols=colnames(wide_data)[c(3:5)]でも可
  names_to = "時期", #属性変数に与える列名（変数名）
  values_to= "得点" #測定変数に与える列名
)

#ロング形式のデータを表示
print(long_data)
```

この例の「性別」列のように，`pivot_longer()`関数実行時に特に何の指定もしなかった変数については，属性変数として，その列名がそのまま使われるとともに，各列に対して自動で適切な値が付与される．

:::ref
<details>
<summary>pivot_longer()の出力の型</summary>
`pivot_longer()`の出力結果は`data.frame`型ではなく`tibble`型となっている．`tibble`は`data.frame`の上位互換のデータ型である．いくつかの違いがあるが，わかりやすい点としては`print()`させたときに，列名に各列の型が表示される点が異なっている．基本的な使い方は`data.frame`と変わらないが，もし`data.frame`にしたければ，`as.data.frmae()`関数を利用すればよい．

```{r}
class(long_data)
long_data <- as.data.frame(long_data)
class(long_data)
```

</details>
:::





:::work
次の[データ](./practice/05_work_1.csv)を読み込み，以下の処理を行え．

1. summay()関数によって，このデータの内容がどのようなものかを確認せよ．
1. 性別と血液型をそれぞれ要因型にし，再度sumary()関数を実施し，先の結果との違いを確認せよ．
1. 性別の`M`を「男性」，`F`を「女性」に置換し，再度sumary()関数を実施し，先の結果との違いを確認せよ．
1. 男性のみのデータを抽出し，そのデータの`身長`の平均値と標準偏差，ならびに平均の95\%信頼区間を求めよ.
1. 女性でかつ`身長`が170㎝以上の人の数が何人か求めよ．
1. BMIが25以上には「過体重」，18.5以上で25未満には「標準」，18.5未満には「低体重」というルールでラベルを付け，新たな列「体重ラベル」としてデータに追加し，その列を要因型に変換して，summary()関数で各ラベルがついた人数を確認せよ．
:::    

    
:::work
次の[データ](./practice/05_work_2.csv)は，調査協力者40名（男性19名，女性21名）に対して，食パンA, B, Cを試食し，風味の良さを10段階で回答してもらったデータである．以下の課題を行え．

1. head()関数によって，このデータの内容がどのようなものかを確認せよ．
1. ワイド形式のデータをロング形式に変換し，同様にhead()関数で内容を確認せよ．
1. ロング形式に変換したデータを用いて，男性の食パンAの平均点と女性の食パンAの平均点をそれぞれ算出せよ．
:::

```{r include=FALSE}
set.seed(44)
# 男性データ
m_height <- round(rnorm(100, 171.5, 6.7),1)#https://www.e-stat.go.jp/dbview?sid=0003224177 を基に平均・標準偏差を算出
m_BMI <- round(rnorm(100, 22.90, 4.1),1)  # https://www.e-stat.go.jp/dbview?sid=0003224178
m_weight <- round(m_BMI * (m_height/100)^2,1)

# 女性データ
f_height <- round(rnorm(100, 157.5, 5.5),1)
f_BMI <- round(rnorm(100, 21.00, 2.9),1)
f_weight <- round(f_BMI * (f_height/100)^2,1)

# 血液型
blood <- sample(c("A", "B", "O", "AB"), 200, replace = TRUE)

# データフレームの作成
gender <- c(rep("M", 100), rep("F", 100))
height <- c(m_height, f_height)
weight <- c(m_weight, f_weight)
bmi <- c(m_BMI, f_BMI)

data <- data.frame(
  性別=gender,
  血液型=blood,
  身長=height,
  体重=weight,
  BMI=bmi
)
write.csv(data, file = "./practice/05_work_1.csv", row.names = FALSE)
```

```{r include=FALSE}
#課題1．1
summary(data)
#　課題2
data$性別 <- as.factor(data$性別)
data$血液型 <- as.factor(data$血液型)
summary(data)
# 課題3
data$性別 <- recode(data$性別, "M"="男性", "F"="女性")
summary(data)
#課題4
res <- filter(data, 性別=="男性")
mean_height <- mean(res$身長)
sd_height <- sd(res$身長)
height_ci <- t.test(res$身長)$conf.int
print(mean_height)
print(sd_height)
print(height_ci)


# 課題5
res<- filter(data, 性別=="女性" & 身長>=170)
nrow(res)

#課題6
data$体重ラベル <- ifelse(data$BMI<18.5, "低体重", ifelse(data$BMI<25, "標準", "過体重"))
data$体重ラベル <- as.factor(data$体重ラベル)
summary(data$体重ラベル)

```


```{r include=FALSE}
set.seed(33)
library(truncnorm)

A <- round(rtruncnorm(40, a=1, b= 10, mean=7, sd = 1.2),0)
B <- round(rtruncnorm(40, a=1, b= 10, mean=5, sd = 1.5),0)
C <- round(rtruncnorm(40, a=1, b= 10, mean=6, sd = 1.3),0)
gender <- sample(c("男性","女性"),40, replace = TRUE)
No <- 1:40

data <- data.frame(
  協力者番号= No,
  性別=gender,
  食パンA=A,
  食パンB=B,
  食パンC=C
)

write.csv(data, file = "./practice/05_work_2.csv", row.names = FALSE)
```

```{r include=FALSE}
# 課題2．1
data <- read.csv("./practice/05_work_2.csv")
head(data)
data_long<-pivot_longer(data, cols=c("食パンA","食パンB","食パンC"), names_to="食パン", values_to="風味")
data_long$性別 <- as.factor(data_long$性別)
head(data_long)

res_m_A <- filter(data_long, 性別=="男性" & 食パン=="食パンA")
res_f_A <- filter(data_long, 性別=="女性" & 食パン=="食パンA")
mean(res_m_A$風味, na.rm = T)
mean(res_f_A$風味, na.rm = T)

```

# まとめ
今回用いた関数は以下の通りである．

- `colnames()`：データフレームの列名を取得する関数.これを左辺に`<-`で新しい列名を収めたベクトルを与えることによって列名（変数名）を置換できる．
  - 第1引数：データフレーム
- `head()`：データフレームの先頭から指定した行数だけを表示する関数
  - 第1引数：データフレーム
  - 第2引数：表示する行数(デフォルトは6)
- `filter()`：デーソースの行を抽出する関数
  - 第1引数：データフレーム
  - 第2引数：フィルタの条件式．=, <, >, |, &を組み合わせて作る
- `ifelse()`：条件分岐を行う関数
　- 第1引数：条件式
  - 第2引数：条件式が`TRUE`の場合の値もしくは式
  - 第3引数：条件式が`FALSE`の場合の値もしくは式
- `recode()`：文字列や要因型の列を置換する関数
  - 第1引数：置換対象のベクトル
  - 第2引数以降：置換内容（`"置換前"="置換後"`）を`, `で区切りながら順に記述する．
- `na.omit()`：欠損データを除外する関数
  - 第1引数：データフレーム
- `pivot_longer()`：ワイド形式のデータをロング形式に変換する関数
  - 第1引数：データフレーム
  - 第2引数：`cols=`でワイド形式で列名になっている属性値を与える．
  - 第3引数：`names_to=`で第2引数で指定した属性値を収めた列に与える属性変数の名を与える．
  - 第4引数：`values_to=`でワイド形式での各値そのものの変数名を与える．


