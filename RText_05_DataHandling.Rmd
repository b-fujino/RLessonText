---
title: "データハンドリング"
author: "藤野秀則,"
date: "`r Sys.Date()`"
output:
  html_document: 
    toc: true
    toc_depth: 4
    toc_float: true
    number_section: true
    fig_width: 8
    css: style.css
  # html_notebook:
  #   toc: true
  #   toc_depth: 3
  #   toc_float: true
  #   number_section: true
editor_options:
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{css, eval=FALSE, echo=FALSE}
.tocify-subheader { /* 全部のサブヘッダーを最初から表示する*/
    display: block !important;
}
.tocify-item {/*長いヘッダーも折り返さない*/
    white-space: nowrap;
}

body{
  counter-reset: ref_number practice_number work_number;
}

.float img{
  /* 上右下左 */
  /* margin: 5% 0% 0% 0% ;*/ 
  /* width : 75%; */
  margin: auto;
  display: block;

  border-radius: 8px 8px 0 0 ;
  position: relative;
  width : 60%;
}

.float .figcaption {
  position: relative;
  font-style: italic;
  font-size: large;
  font-weight: bold;
  color: #666;
  text-align: center;
  margin:0% auto 5% auto;
  border-bottom: solid 1px #666;
  border-left: solid 1px #666;
  border-right: solid 1px #666;
  border-radius:0 0 8px 8px;
  width : 60%
}

img {
  margin: auto;
  display: block;
  border: solid 1px #666;
  border-radius: 8px;
  position: relative;
  width : 100%;
}

.ref {
  position: relative;
  margin:5%;
  padding:5px;
  background-color: rgba(255, 255, 128, .5);
  color: #666;
}
.ref::before{
  counter-increment: ref_number 1;
  content: "[参考 " counter(ref_number) "]";
  font-weight: bold;
  display: block;
  margin-bottom: 3px;
}

h1 {
  margin-top : 10px;
  padding-top : 50px;
}


.practice {
  position: relative;
  margin:5%;
  padding:5px;
  background-color: rgba(128, 255, 200, .5);
  color: #666;
}
.practice::before{
  counter-increment: practice_number 1;
  content: "[例題 " counter(practice_number) "]";
  font-weight: bold;
  display: block;
  margin-bottom: 3px;
}




.work {
  position: relative;
  margin:5%;
  padding:5px;
  background-color: rgba(128, 200, 255, .2);
  color: #666;
}
.work::before{
  counter-increment: work_number 1;
  content: "[課題 " counter(work_number) "]";
  font-weight: bold;
  display: block;
  margin-bottom: 3px;
}




.r{ 
　/**copy の禁止**/
  user-select: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
  -khtml-user-select: none;
  -webkit-touch-callout: none;
}
```


以下では具体的な例を示すためにRに最初から入っているデモ用データの`iris`を用いる。
irisデータはアイリス（菖蒲）のがく(Sepal)と花びら(Petal)の長さ(length)と幅(width)の実測データが3つの種類（`Setosa`, `vergicolor`, `virginica`）ごとに50点ずつ格納されている。
内容を確認するために、`summary()`関数と`head()`関数（データフレームの冒頭データを出力させる関数)を実行してみた。

```{r }
data_iris <- iris #irisデータを呼び出してdというオブジェクトに格納
summary(data_iris)
head(data_iris)
```

列名が英語のままだと分かりにくいので、日本語に翻訳した名前に置き換える(-\>[参考](./RText_03_BasicUsage2.html#列名へのアクセスと変更))。以下はそのためのコード。
```{R}
colnames(data_iris) <-  c("がく長","がく幅","花びら長","花びら幅","種類")
head(data_iris)
```


# 抽出


グループ分け変数を持ったデータを処理するときには、ある特定のグループのデータだけを抜き出したいということはよくある。
そうした「データの抽出」を行うための関数として`tidyverse`パッケージには`filter()`関数が設けられている。利用するためにはTools-\>install.packagesで`tidyverse`パッケージをインストールしたうえで、スクリプト上で`library(tidyverse)`と入力してパッケージを読み込む必要がある。

`filter()`関数の利用法は、第1引数に元のデータを与え、第2引数に検索条件を与える。検索条件の書式のパターンは以下の通り。

|書式|動作|
|:--|:----------|
|元データ\$列名==Key|列名で指定した列の値がKeyと一致しているものを抽出。「=」を重ねる点がポイント。|
|元データ\$列名>Key|列名で指定した列の値がKeyよりも大きいものを抽出|
|元データ\$列名>=Key|列名で指定した列の値がKeyと等しいかKeyよりも大きいものを抽出|
|元データ\$列名<Key|列名で指定した列の値がKeyよりも小さいものを抽出|
|元データ\$列名<=Key|列名で指定した列の値がKeyと等しいかKeyよりも小さいものを抽出|




```{r}
library(tidyverse)

summary(data_iris)
res<- filter(data_iris, data_iris$種類=="virginica")
summary(res)
res <- filter(data_iris, data_iris$がく長<=5)
summary(res)
res <- filter(data_iris, data_iris$がく長>=6)
summary(res)
```

条件は複数並べることもできる。`|`は複数の条件のいずれかにマッチすれば抽出される。`&`は複数条件の全てにマッチするものが抽出される。
それぞれ以下に示す。
```{r}
res <- filter(data_iris, data_iris$がく長>=6 | data_iris$花びら長>1.5)
summary(res)
res <- filter(data_iris, data_iris$がく長>=6 & data_iris$花びら長>1.5)
summary(res)
res <- filter(data_iris, data_iris$がく長>=5 & data_iris$がく長<6.5) # 5<=がく長<6.5
summary(res)
res <- filter(data_iris, data_iris$がく長<5 | data_iris$がく長>=6.5) # がく長<5, 6.5<=学長
summary(res)

```
抽出したデータのある列だけが必要だという場合には、抽出したデータを収めたオブジェクトにに`$`や`[]`をつけて指定すればよい。以下では内容を確認するため、`head()`関数を使って最初の数行だけを表示させている。

```{r}
res <- filter(data_iris, data_iris$がく長>=6 | data_iris$花びら長>1.5)
res<- res$花びら長
head(res)

res <- filter(data_iris, data_iris$がく長>=6 | data_iris$花びら長>1.5)
res<- res["花びら長"]
head(res)



#次のように関数に対して直接[]や$を書ける
res2 <- filter(data_iris, data_iris$がく長>=6 | data_iris$花びら長>1.5)$花びら長
head(res2)

#次のように関数に対して直接[]や$を書ける
res2 <- filter(data_iris, data_iris$がく長>=6 | data_iris$花びら長>1.5)["花びら長"]
head(res2)

#複数の列を取り出す場合には[c()]を使う
res3 <- filter(data_iris, data_iris$がく長>=6 | data_iris$花びら長>1.5)[c("花びら長","花びら幅")]
head(res3)

```
`$`と`[]`とで出力が違うのは[こちら](#列（ベクトル）へのアクセス)で説明したように、`$`は指定した列をベクトルとして取り出すのに対して、`[]`は指定した列だけで構成されるデータフレームとして取り出されるためである。

<!--以下、2024/5/16　追記 -->

# 数値の置換
数値の置換には`ifelse()`関数を応用する。`ifelse()`関数は、第1引数に条件を記述し（条件の記述方法は検索と同じ）、第2引数には条件にマッチした場合に置き換える値、第3引数にはマッチしなかった場合に置き換える値を記載する。`ifelse()`関数の実行結果として最終的に返ってくるのは、そうした置き換えが行われたベクトルとなる。あくまでベクトルが返ってくるだけなので、実際に置き換えをデータに反映させるためには、元のデータの元の列に返ってきたベクトルを代入するなり、元のデータに新しい列を作ってベクトルを代入するなりする必要がある。

:::ref
「値」と記載しているが、コンピュータの用語として「値」という場合には、数値だけでなく文字列も含められていることは覚えておこう。数値だけをいう場合には「数値」、文字列だけを言う場合には「文字列」とはっきりと言わなければならない。
:::

以下の例ではがく長が平均値より上か下かで平均以上なら1、未満なら0を割り当てる変数を作っている。

```{R}
data_iris2 <- data_iris 
data_iris2$bがく長 <- ifelse(data_iris2$がく長 >= mean(data_iris2$がく長), 1, 0)
summary(data_iris2)
data_iris2$bがく長 <- as.factor(data_iris2$bがく長)
summary(data_iris2)
```

# 文字列の置換

文字列型の列や要因型の列を置換したい場合には`ifelse()`関数を使うよりも、`recorde()`関数を使うほうが簡単である。変換したいものの対応を第2引数に以下の例の通りに与えればよい。変換式が指定されていないものは元の値が維持される。
```{R}
data_iris2 <- data_iris 
data_iris2$種類 <- recode(data_iris2$種類, "setosa"="セトサ", "versicolor"="バーシカラー")
summary(data_iris2$種類)
```

もちろん`ifelse()`関数を使うこともできるが、列が要因型の場合には、一旦文字列型に変換してからでないと、思ったような結果とならない場合がある。例えば、以下の例では`setosa`だけを`セトサ`に置き換えたいと思って実行したのにもかかわらず、列が要因型ではなく勝手に文字列型にされ、さらに、他のもの種類名も勝手に`2`や`3`に設定されてしまっているのがわかる。
```{r results='hold'}
data_iris2 <- data_iris
data_iris2$種類 <- ifelse(data_iris2$種類=="setosa", "セトサ", data_iris2$種類 )
summary(data_iris2$種類) #サマリー表示 classがCharacter（文字列型）となっている
data_iris2$種類 #中身を確認してみる
```
意図した通りのことをしたいならば、以下のようになる。
```{r results='hold'}
data_iris2 <- data_iris
data_iris2$種類 <- as.character(data_iris2$種類) #要因型から文字列型に変換
data_iris2$種類 <- ifelse(data_iris2$種類=="setosa", "セトサ", data_iris2$種類 )
data_iris2$種類 #中身を確認してみる
summary(data_iris2$種類) #サマリー表示
data_iris2$種類 <- as.factor(data_iris2$種類) #文字列型から要因型に変換
summary(data_iris2$種類) #サマリー表示　要因型に変換したので表示が変わる
```

# 欠損データの除外

実験や調査を行った際にデータの一部が欠損しているケースは多々ある。Rでは欠損データはデータフレーム上で`NA`（Not Available：利用不可能の意味）と表記されている。

関数によっては欠損データを含んでいるデータを受け付けないケースがある。例えばすでに[平均値](#平均値)で紹介したように`mean()`関数は、そのままでは欠損値を含んだデータは受け付けない。

`mean()`関数では、関数の引数で`na.rm = T`を設定しておくと関数処理の中で`NA`を除いて処理してくれるが、そもそも与えるデータそのもので`NA`を除いておくほうが望ましい。

例えば、次のようなデータを処理するケースを考えよう。これはAからFまでの6人に対して10問セットの2種類のクイズを解いてもらった時のスコアである。ただ、1つめのデータセットではDさんのデータが、2つめのデータではEさんのデータが欠損してしまっている。このスコアをもとに、どちらのデータセットが難しいデータだったのかを比べたい。そこで、それぞれの平均や標準偏差を求めてみた。欠損データを含んでいるので`na.rm=T`を設定した。さて、このやり方は正しいだろうか。


```{r}
data_iris3 <- data.frame(
  name = c("A", "B", "C", "D", "E", "F"),
  score1 = c(9,8,9,NA,6,7),
  score2 = c(8,7,8,10,NA,7)
)

mean(data_iris3$score1, na.rm=T)
sd(data_iris3$score1, na.rm=T)

mean(data_iris3$score2, na.rm=T)
sd(data_iris3$score2, na.rm=T)
```

このデータの場合、平均や標準偏差を単純比較してはまずい。理由として`score1`ではD以外のデータが使われているのに対して、`score2`ではE以外のデータが使われているからである。すなわち、それぞれを計算するときに使われたデータが異なっているからである。もしDさんがクイズがすごく得意な人であったならば、Dさんのデータが入っていない`score1`の方は、不当に低くくなってしまっているであろうし、逆にEさんがクイズが苦手な人であったならば、Eさんのデータが入っていない`score2`の方は不当に高くなっている可能性がある。

データを比較するときには、比較しようとしている項目以外で結果に影響を与えると考えられる項目（条件）は同一条件となっている、ということが大前提である。したがって、上記のようなデータを比較するときには、2種類のクイズのデータが両方ともそろっているA,B,C,Fの4人のデータだけで比較するべきである。

このように、データの一部に欠損値を含んでいるよな観測をすべて除外して、すべての変数でデータがそろっているものだけを残すには、`na.omit()`関数を用いる。
```{r}
data_iris3.naomit <- na.omit(data_iris3)
data_iris3.naomit

mean(data_iris3.naomit$score1)
sd(data_iris3.naomit$score1)
mean(data_iris3.naomit$score2)
sd(data_iris3.naomit$score2)
```

こうした欠損値は特に任意回答の項目を入れているアンケート調査では間違いなく含まれてくるし、紙でとったアンケート調査においては無回答であったり、択一回答の質問なのに勝手に2つ以上の選ぶなど不正回答をしてくるケースも多々ある。そういう場合にはデータ上は`NA`として処理すべきデータとなる。そのような形で`NA`を含んだデータではデータを読み込んだ時点で上記の通りに`na.omit()`を実施しておくとよい。

# データの整理方法（ワイド形式とロング形式）

例えば、ある中学校のあるクラス(25人)での1年間の定期テストでの数学の得点をデータとして扱う事例を考えてみよう。

人がそのようなデータを扱うときには以下のような表を作るだろう。

| 学生番号 | 前期中間 | 前期期末 | 後期中間 | 後期期末 |
|:--|:--|:--|:--|:--|
| 1          | 75            | 94          | 89             | 65           |
| 2          | 60            | 81          | 70             | 95           |
| 3          | 68            | 84          | 65             | 70           |
| 4          | 99            | 78          | 80             | 88           |
| 5          | 73            | 59          | 85             | 64           |
|・・・|・・・|・・・|・・・|・・・|・・・|
| 24         | 85            | 62          | 75             | 88           |
| 25         | 72            | 77          | 87             | 92           |
<!-- | 6          | 79            | 93          | 55             | 80           | -->
<!-- | 7          | 96            | 97          | 76             | 85           | -->
<!-- | 8          | 56            | 78          | 58             | 89           | -->
<!-- | 9          | 77            | 60          | 94             | 97           | -->
<!-- | 10         | 83            | 74          | 99             | 82           | -->
<!-- | 11         | 71            | 88          | 86             | 77           | -->
<!-- | 12         | 55            | 71          | 80             | 91           | -->
<!-- | 13         | 81            | 83          | 67             | 87           | -->
<!-- | 14         | 67            | 61          | 54             | 99           | -->
<!-- | 15         | 92            | 75          | 99             | 72           | -->
<!-- | 16         | 74            | 79          | 97             | 76           | -->
<!-- | 17         | 87            | 64          | 96             | 55           | -->
<!-- | 18         | 58            | 94          | 71             | 84           | -->
<!-- | 19         | 93            | 96          | 92             | 69           | -->
<!-- | 20         | 64            | 66          | 83             | 78           | -->
<!-- | 21         | 69            | 91          | 90             | 75           | -->
<!-- | 22         | 84            | 73          | 68             | 81           | -->
<!-- | 23         | 70            | 65          | 78             | 94           | -->


このようなデータの並べ方を**「ワイド形式」**と呼ぶ。ワイド形式は一般に人がみてわかりやすい表形式となる。
それに対して、Rで扱う表は以下のような並べ方のデータを並べている方が扱いやすい。このような並べ方を**「ロング形式」**と呼ぶ。

|データNo.| 生徒番号 | 時期     | 得点 |
|:--|:--|:--|:--|
|1| 1          | 前期中間  | 75    |
|2| 1          | 前期期末    | 94    |
|3| 1          | 後期中間 | 89    |
|4| 1          | 後期期末   | 65    |
|5| 2          | 前期中間  | 60    |
|6| 2          | 前期期末    | 81    |
|7| 2          | 後期中間 | 70    |
|8| 2          | 後期期末   | 95    |
|9| 3          | 前期中間  | 68    |
|10| 3          | 前期期末    | 84    |
|11| 3          | 後期中間 | 65    |
|12| 3          | 後期期末   | 70    |
|13| 4          | 前期中間  | 99    |
|・・・|・・・|・・・|・・・|
|92| 23         | 後期期末   | 94    |
|93| 24         | 前期中間  | 85    |
|94| 24         | 前期期末    | 62    |
|95| 24         | 後期中間 | 75    |
|96| 24         | 後期期末   | 88    |
|97| 25         | 前期中間  | 72    |
|98| 25         | 前期期末    | 77    |
|99| 25         | 後期中間 | 87    |
|100| 25         | 後期期末   | 92    |

ワイド形式では列は測定された変数の「属性」を並べるのに対して、ロング形式では「属性」は一つの変数として個別に列立てされて並べる点が異なる。

また、ワイド形式の場合、例えば、数学の得点を並べた表とは国語の得点を並べた表ば別個に作成する必要がある。
一方で、ロング形式の場合、数学の得点の列、国語の得点の列、というように並べて行けばよい。

データ処理という点では、人の目からはわかりづらいがロング形式のデータにしておく習慣を持っておこう。

なお、`tidyverse`パッケージ（正確には`tidyr`パッケージ）ではワイド形式のデータをロング形式のデータに変換する`pivot_longer()`関数が存在している。もし外部から提供されたデータがワイド形式であった場合には、`pivot_longer()`関数を用いればよい（もちろん、Excelで手作業で並べ変えを行っても構わない）。

```{R}
# ワイド形式のデータフレームを作成
wide_data <- data.frame(
  id = 1:3,
  time1 = c(10, 20, 30),
  time2 = c(40, 50, 60),
  time3 = c(70, 80, 90)
)

# ワイド形式のデータを表示
print(wide_data)

# ロング形式に変換
long_data <- pivot_longer(
  wide_data,
  cols=colnames(wide_data)[c(2:4)], #cols=c("time1","time2","time3")でも可
  names_to = "time", #属性変数に与える列名（変数名）
  values_to= "値" #測定変数に与える列名
)

#ロング形式のデータを表示
print(long_data)
```

ちなみに、`pivot_longer()`の出力結果は`data.frame`形式ではなく`tibble`形式となっている。`tibble`形式は`data.frame`形式の上位互換のデータ形式である。いくつかの違いがあるが、わかりやすい点としては`print()`させたときに、列名に各列の型が表示される点である。基本的な使い方は`data.frame`形式と変わらないが、もし`data.frame`形式にしたければ、`as.data.frmae()`関数を利用すればよい。

```{r}
class(long_data)
long_data <- as.data.frame(long_data)
class(long_data)
```

