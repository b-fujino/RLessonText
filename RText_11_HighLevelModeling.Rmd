---
title: "回帰モデルの発展：分散分析と回帰分析の融合"
author: "藤野秀則"
date: 
  初稿日:"2024-10-08"
  更新日:`r Sys.Date()`
output:
  html_document: 
    toc: true
    toc_depth: 4
    toc_float: true
    number_section: true
    fig_width: 8
    css: ./style.css
editor_options:
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

これまでは**回帰分析説明変数・目的変数ともに連続変数**の場合に用い，**分散分析は説明変数がカテゴリカル変数，目的変数が連続変数**の場合に用いるとして，それぞれ別々に説明してきた．また，分散分析では交互作用を含めたモデルについて触れたが，回帰分析ではそれは触れていない，などの違いもあった．

しかし実際には分散分析は回帰分析の一種であり，回帰分析と分散分析は同じ枠組みの中で説明・実施できる．
今回はそれらについて説明する．


# ダミー変数を用いた回帰分析

先にも述べているように，一般に**回帰分析説明変数・目的変数ともに連続変数**，**分散分析は説明変数がカテゴリカル変数，目的変数が連続変数**，というように使い分けられている．

しかし実際には，**0，1の2値を取るダミー変数**と呼ばれる変数を導入し，カテゴリカル変数の各水準をダミー変数として表現することによってことによって，回帰分析においても説明変数にカテゴリカル変数を含めることができる．

例1　性別（男・女）のような2つの水準を持つカテゴリカル変数を説明変数として回帰分析を行う場合，以下のように1つのダミー変数を導入することによって，回帰分析を行うことができる．

| |$X$|
|:---|:---:|
|男|0|
|女|1|


例2　A,B,Cという3つの水準を持つカテゴリカル変数を説明変数として回帰分析を行う場合，以下のように2つのダミー変数を導入することによって．

| |$X_1$|$X_2$|
|:---|:---:|:---:|
|A|0|0|
|B|1|0|
|C|0|1|

このように，$n$個の水準を持つカテゴリカル変数を説明変数に含めて回帰分析を行う場合，$n-1$個のダミー変数を導入することによって，回帰分析を行うことができる．

## 2水準をもつカテゴリカル変数を含んだ回帰分析

:::practice
[このデータ](./practice/example_11_Dammy.csv)は，ある企業の従業員600人のデータである．データは，性別（0:女性，1:男性）, その企業での就労期間（連続変数），過去1年間の月当たりの平均残業時間（連続変数），その企業の従業員のの過去1年間の平均月収（単位：万円）を記録したものである．このデータをもとに，平均月収を予測する式を作れ．

```{r include=FALSE}
#あとの例を考えて，学歴も加えて，交互作用項も加えているが，ここでは，CSVには学歴を外して保存する．

set.seed(113)

# サンプルサイズ
n_m <- 400
n_f <- 200

# 定数設定
base <- 20 #基本給
up <- 0.7 #就労期間に対するベースアップ
base.univ<-4 #大卒のベースライン
up.univ <- 0.08 #大卒の昇給プレミアム
base.grad<-7 #院卒のベースライン
up.grad <- 0.12 #院卒の昇給プレミアム
#就労期間による残業時間のプレミアム

#男性データ
gender_m <- rep(1, n_m)
# 就労期間 (0~40年)
experience_m <- round(runif(n_m, min = 0, max = 40), 0)
# 平均残業時間
hours_worked_m <- round(abs(rnorm(n_m, mean=21, sd=10)), 1)
# 学歴
edu_m<- sample(0:2, n_m, replace = TRUE,prob=c(2/10,5/10,3/10) )
# 収入 (従属変数): 
income_m <- base +  up*experience_m + (base +  up*experience_m)/21/8*1.15 * hours_worked_m +#ベースライン 
   (base.univ+up.univ*experience_m) * ifelse(edu_m==1,1,0) + #大卒のプレミアム
   (base.grad+up.grad*experience_m) * ifelse(edu_m==2,1,0) + #院卒のプレミアム
   (base.univ+up.univ*experience_m)/21/8*1.15 * ifelse(edu_m==1,1,0)*hours_worked_m +　#大卒の残業代プレミアム
   (base.grad+up.grad*experience_m)/21/8*1.15 * ifelse(edu_m==2,1,0)*hours_worked_m +　 #院卒のプレミアム  
　 experience_m/7 *rnorm(n_m, mean = 0, sd = 1) # 能力差のプレミアム（経験年数が高まるほど差分は大きくなる）
# データフレームを作成
data_m <- data.frame(
  性別 = gender_m,
  学歴 = edu_m,
  就労期間 = experience_m,
  残業時間 = hours_worked_m,
  平均月収 = income_m
)


#女性データ
gender_f <- rep(0, n_f)
# 就労期間
experience_f <- c(
  round(runif(n_f/4, min = 0, max = 10), 0),
  round(runif(n_f/4, min = 0, max = 20), 0),
  round(runif(n_f/4, min = 0, max = 30), 0),
  round(runif(n_f/4, min = 0, max = 40), 0)
)
# 学歴
edu_f<- sample(0:2, n_f, replace = TRUE,prob=c(3/10,6.5/10,0.5/10) )
# 平均残業時間
hours_worked_f <- round(abs(rnorm(n_f, mean=10, sd=5)), 1)
# 収入 (従属変数): 
income_f <- base +  up*experience_f + (base +  up*experience_f)/21/8*1.15* hours_worked_f +#ベースライン 
   (base.univ+up.univ*experience_f) * ifelse(edu_f==1,1,0) + #大卒のプレミアム
   (base.grad+up.grad*experience_f) * ifelse(edu_f==2,1,0) + #院卒のプレミアム
   (base.univ+up.univ*experience_f)/21/8*1.15 * ifelse(edu_f==1,1,0)*hours_worked_f + #大卒の残業代プレミアム
   (base.grad+up.grad*experience_f)/21/8*1.15 * ifelse(edu_f==2,1,0)*hours_worked_f + #院卒のプレミアム  
　 experience_f/7 *rnorm(n_f, mean = 0, sd = 1) # 能力差のプレミアム（経験年数が高まるほど差分は大きくなる）

# データフレームを作成
data_f <- data.frame(
  性別 = gender_f,
  学歴 = edu_f,
  就労期間 = experience_f,
  残業時間 = hours_worked_f,
  平均月収 = income_f
)

# 男女を結合
data <- rbind(data_m, data_f)
#データフレームのCSVへの書き込み
write.csv(data, file = "./practice/example_11_Dammy2.csv", row.names = FALSE)
fit <- lm(平均月収 ~ (性別 + factor(学歴)+残業時間)*就労期間, data = data)
summary(fit)


#学歴除外してCSVに書き込み
data$学歴<-NULL
write.csv(data, file = "./practice/example_11_Dammy.csv", row.names = FALSE)


```
:::

この例のデータの場合には，性別をダミー変数として導入することになる．今回のデータの場合には既に性別は0,1でコード化されているので，読み込んだデータをそのまま`lm()`関数に渡すことで回帰分析を行うことができる．

```{r}
data <- read.csv("./practice/example_11_Dammy.csv")
fit_gender <- lm(平均月収 ~ 性別 + 就労期間 + 残業時間, data = data)
summary(fit_gender)
```

この結果から，以下のような予測式を立てることができる．

$$
平均月収= 22.01 + 9.13 \times 性別 + 1.16 \times 就労期間 + 0.38 \times 残業時間
$$

つまり，性別が1，すなわち男性の場合には平均月収が約9万円高くなる，就労期間が1年長くなると11600円高くなる，残業時間が1時間伸びると3800円高くなる，ということが分かる．
また，いずれの回帰係数も有意であり，性別，就労期間，残業時間は平均月収に対して有意な影響を与えていることが分かる．

:::ref
<details>
<summary><a name="カテゴリカル変数を含んだ回帰分析のイメージ"></a>カテゴリカル変数を含んだ回帰分析のイメージ</summary>
カテゴリカル変数を含んだ回帰分析は一体どういうことを行っているのかを理解するには，データを図示してみればよい．
先のデータを図示してみると，以下の通りとなる．
なお，残業時間については平均値(=40.998)を取る（すなわち全員が約41時間の残業をしている）ものと仮定している．

```{r}
library(ggplot2)
data$性別 <- as.factor(data$性別)
ggplot(data, aes(x = 就労期間, y = 平均月収)) + 
  geom_point(aes(color=性別)) + 
  scale_x_continuous(limits=c(0,40), breaks = seq(0, 40, 5)) +
  scale_y_continuous(limits=c(20,70),breaks = seq(0, 70, 20)) +
  geom_abline(intercept = coef(fit_gender)[1]+coef(fit_gender)[4]*mean(data$残業時間), 
              slope = coef(fit_gender)[3], color = "red")+ 
  geom_abline(intercept = coef(fit_gender)[1]+coef(fit_gender)[2]+coef(fit_gender)[4]*mean(data$残業時間),
              slope = coef(fit_gender)[3], color = "blue") +
  scale_color_discrete(label=c("女性", "男性")) 

```


男性と女性とで傾きは同じであるが切片は異なっている．

つまりカテゴリカル変数を導入した回帰分析とは，**カテゴリカル変数の各水準によって切片が異なっているが，傾きは同じである**という仮定を置いた回帰分析ということである（[注1](#Dammy注1)）．

この仮定を置かなかった場合（つまりカテゴリカル変数を説明変数に加えなかった場合）には，以下の黒色の直線となる．

```{r}
fit_no_gender <- lm(平均月収 ~ 就労期間 + 残業時間, data = data)
summary(fit_no_gender)

ggplot(data, aes(x = 就労期間, y = 平均月収)) + 
  geom_point(aes(color=性別)) +   scale_color_discrete(label=c("女性", "男性")) +
  scale_x_continuous(limits=c(0,40), breaks = seq(0, 40, 5)) +
  scale_y_continuous(limits=c(20,70),breaks = seq(0, 70, 20)) +
  geom_abline(intercept = coef(fit_gender)[1]+coef(fit_gender)[4]*mean(data$残業時間), 
              slope = coef(fit_gender)[3], color = "red")+ 
  geom_abline(intercept = coef(fit_gender)[1]+coef(fit_gender)[2]+coef(fit_gender)[4]*mean(data$残業時間),
              slope = coef(fit_gender)[3], color = "blue") +
  geom_abline(intercept = coef(fit_no_gender)[1]+coef(fit_no_gender)[3]*mean(data$残業時間),
              slope = coef(fit_no_gender)[2], color = "black")
```

つまり，男女別を考慮せずに分析した場合と，男女別を考慮した場合とでは就労期間の平均月収に対する影響力が異なっている，ということである．
また，自由度調整済み決定係数を見てみると，男女別を考慮した場合の方が高いことから，男女別を考慮した方がより適切なモデルであると言える．

さらに，以下の`anova()`関数を用いることによって，この2つのモデルに有意な差があるかどうかを検定することもできる．
```{r}
anova(fit_gender, fit_no_gender)
```

このように，カテゴリカル変数を導入して，グループごとに切片の値が異なっているという前提で分析を行うことによって，モデル全体の予測力が向上することがある．もちろん，導入しても大して予測力の向上が見られない（カテゴリカル変数が有意にならない）のであれば，カテゴリカル変数を導入する必要はない．

<a name="Dammy注1">注1：</a>切片も傾きも異なるという仮定もあり得て，それが次に説明する交互作用項を含んだモデルである[参考](#交互作用を含む分析)．

</details>
:::

:::ref
<details>
<summary>分散分析との相違点</summary>
回帰分析でダミー変数を導入するのと同様に，分散分析で連続変数を導入することもできる．
たとえば，上記の例を分散分析で行うと以下の通りとなる（タイプ2の分散分析になることに注意！）．

```{r}
library(car)
data$性別 <- as.factor(data$性別)
Res_aov <- aov(平均月収 ~ 性別 + 就労期間 + 残業時間, data = data)
Anova(Res_aov, type = 2)
```
P値が先ほどの回帰分析の結果と同じであることが確認できる．
すなわち，就労時間や残業時間を統制したうえで，性別の影響が平均月収に対して有意であることが分かる．

このように，回帰分析の結果と分散分析の結果は一致する．ただし，分散分析の場合には実際にカテゴリ間にどの程度の差があるのかまでは分からない([参考](#ダミー参考))．

  
<details>
<summary><a name="ダミー参考">参考</a></summary>
以下のように単純に男女に分けてそれぞれの平均を求めるという方法は誤りである．このような単純な平均の差は男女間での就労期間の差や残業時間の差を考慮していないため，男女間の平均月収の差を正確に評価することができない．
```{r}
aggregate(平均月収 ~ 性別, data = data, mean)
```
</details>

</details>
:::


## 多水準をもつカテゴリカル変数を含んだ回帰分析
先ほどは性別(2水準)を含んだ回帰分析を行ったが，3水準以上のカテゴリカル変数を含んだ回帰分析を行う場合には，ダミー変数を導入する際には，$\text{その水準数}-1$個のダミー変数を導入する必要がある．

:::practice
[このデータ](./practice/example_11_Dammy2.csv)は先ほどの従業員の月収に関するデータに各サンプルの学歴(0:高卒，1:大卒，2:院卒)も加わえたデータである．性別，学歴，就労期間，残業時間を説明変数として，平均月収を予測する式を作れ．

```{r eval=FALSE, include=FALSE}
set.seed(113)

# サンプルサイズ
n <- 50

# ダミー変数: 性別 (0=女性, 1=男性)
gender <- sample(0:1, n, replace = TRUE)

# 連続変数: 就労期間 (0~30年)
experience <- round(runif(n, min = 0, max = 30), 1)

# 連続変数: 平均残業時間(20~60時間)
hours_worked <- round(runif(n, min = 20, max = 60), 1)

# 収入 (従属変数): 
income <- 24 +  experience + 0.4* hours_worked + 6 * gender + 0.8*rnorm(n, mean = 0, sd = 10)

# データフレームを作成
data <- data.frame(
  性別 = gender,
  就労期間 = experience,
  残業時間 = hours_worked,
  平均月収 = income
)

library(tidyverse)
男性 <- data %>% filter(性別 == 1)
女性 <- data %>% filter(性別 == 0)

# ダミー変数: 学歴 (0=高卒, 1=大卒, 2=院卒) 
# 男性は2/3が大卒か院卒，残り1/3が高卒か大卒
学歴_男 <- sample(0:2, nrow(男性), replace = TRUE,prob=c(1/12,5/12,6/12) )
# 男性データに学歴を付与
男性$学歴 <-学歴_男

# 女性は2/3が高卒か大卒，残り1/3が大卒か院卒
学歴_女 <- sample(0:2, nrow(女性), replace = TRUE, prob=c(1/12,10/12,1/12))
# 女性データに学歴を付与
女性$学歴 <- 学歴_女

# 男女を結合
data <- rbind(男性, 女性)

# 平均月収に院卒・大卒のプレミアムを付与
data$平均月収 <- data$平均月収 + 7*(data$学歴-1)

#データフレームのCSVへの書き込み
write.csv(data, file = "./practice/example_11_Dammy2.csv", row.names = FALSE)
```
:::

この例のデータの場合には，性別に加えて学歴をダミー変数として導入することになる．学歴は3水準を持つカテゴリカル変数であるため，2つのダミー変数を導入することになる．
ただ，Rではわざわざ手作業でダミー変数を用意する必要はない．**Rでは，カテゴリカル変数のクラスを`factor`型に変換しておくことによって，自動的にダミー変数が作成される**．

`factor`型への変換はデータを読み込んだ際に`as.factor()`関数を用いて予め行っておく．

```{r}
data <- read.csv("./practice/example_11_Dammy2.csv")
data$学歴<- as.factor(data$学歴)
fit_edu <- lm(平均月収 ~ 性別 + 学歴 + 就労期間 + 残業時間, data = data)
summary(fit_edu)
```
この結果の見方として，学歴1，学歴2という2つの変数が追加されているが，これはそれぞれ学歴1が大卒の，学歴2が院卒のダミー変数である．高卒については基準として用いられるため明示的には結果には表れない（要するに学歴1の値が0，学歴2の値が0の時が高卒）．

:::ref
<details>
<summary>大卒・院卒のダミー変数について</summary>
各従業員の学歴のダミー変数について，Rが自動で付与するダミー変数では大卒，院卒に対応するダミー変数は**互いに排他的に**作成される．しかし，学歴のデータとしては，大卒者は当然高卒でもあるし，院卒は大卒でもある．したがって，以下の表のようなダミー変数の作り方も可能である．

| |$X_1$|$X_2$|
|:---|:---:|:---:|
|高卒|0|0|
|大卒|1|0|
|院卒|1|1|

このようなダミー変数として分析を行った場合には，大卒属性が付くと月収がいくら上がるのか，**さらに**院卒属性がつくと月収がいくら上がるのか，ということを明らかにすることができる．

このようなダミー変数にするには，手作業でダミー変数を作る必要がある．手作業でダミー変数を作るのはExcelなどの表計算ソフトを使ってやっても良いが，Rでするとすれば，下のようなソースコードにすればよい.

```{r eval=FALSE}
data$学歴1 <- ifelse(data$学歴 == 1 | data$学歴 == 2, 1, 0)
data$学歴2 <- ifelse(data$学歴 == 2, 1, 0)
```

これは，[`ifelse()`関数](./RText_05_DataHandling.html#数値の置換)を用いて学歴1，学歴2というダミー変数を作っているが，特に学歴1については，第1引数を`data$学歴 == 1 | data$学歴 == 2`という形で，「または」を意味する`|`演算子を用いて二つの条件を結合（論理和）させている．（[参考](#論理積)）

<a name="論理積">参考</a>
ちなみに「かつ」で結合（論理積）させたい場合には`&`演算子を用いる．
</details>
:::


式に表すと，以下の通りとなる．

$$
\begin{align}
平均月収= &16.70 + 3.49 \times 性別 + 2.91\times 学歴1 + 12.29\times 学歴2 + \\
&\quad 1.08 \times 就労期間 + 0.47 \times 残業時間\\
\text{ただし} &\quad \{性別:女性\rightarrow 0, 男性\rightarrow 1\}, \\
&\quad \{学歴1:大卒\rightarrow 1, それ以外\rightarrow 0\},\\ 
&\quad \{学歴2:院卒\rightarrow 1, それ以外\rightarrow 0\}
\end{align}
$$
この結果から，性別が男性の場合には平均月収が約3.49万円高くなる，大卒の場合には高卒に比べて約2.91万円高くなり，院卒の場合には約12.29万円高くなる，就労期間が1年長くなると10800円高くなる，残業時間が1時間伸びると4700円高くなる，ということが分かる．

ただし，性別については有意ではない．つまり3.49万円というのは誤差の範囲に収まっており，男女の差は平均月収に対して有意な影響を与えていないということである．同様に，学歴1についても有意ではなく，高卒か大卒かは平均月収に対して有意な影響を与えていないという結果となった．

:::ref
<details>
<summary>結果についての考察</summary>
[先ほどの結果](#2水準をもつカテゴリカル変数を含んだ回帰分析)では性別で極めて大きな差がついていた．つまり，先ほどの結果だけみれば，この会社は男女で給与に大きな差をつけている会社，つまり男性優位の古い体質の会社である，という印象となってしまう．

しかしながら，学歴も説明変数に加えると，性別の影響は小さく学歴の影響が大きいことが分かる．

これらの結果から，この会社では学歴が平均月収に対して大きな影響を与えるとともに，院卒者は女性より男性が多いのではないか，という予想が建てられる．

そこで，実際に性別と学歴のクロス集計を行ってみると以下の通りとなる．
```{r}
tb<-table(data$性別, data$学歴)
dimnames(tb) <- list(c("女性", "男性"), c("高卒", "大卒", "院卒")) # tbだと行列に名前がないので名前を付与
print(tb)
```

この結果から，男性では高収入な院卒者が過半数である一方，女性は院卒者は1名しかおらず，残り23名は全員が大卒であることが分かる．
また，逆に高卒は男性で3名いるだけ，という結果となっている．

このように，男女で雇用されている従業員の学歴の分布が大きく異なっていたため，学歴を考慮せずに男女差だけを考えると，女性の方が給与が低い，という結果になってしまっていたのである．

メーカー系の大企業では一般に技術者の採用は工学系の院卒者が多くなる．そして工学の院卒は現時点の日本では圧倒的に男性が多い（そもそも工学部自体が男性が圧倒的に多い）．その結果として院卒者の採用は男性に偏ることになる．そして，そのバランスをとるために事務系では女性を多く採用するということは当然あり得る．また高卒については，メーカー系の場合，おもに工業高校から現業職として採用するケースが多いが，やはり工業高校の男女比は男性に偏りがちであるため，男性が多くなりやすい．今回のサンプルデータも，このような社会的事情が反映されたものと推察される．

ともかく，学歴を考慮せずに単純に男女だけで比較をすると，その結果は誤ったものとなることが分かるだろう．このように説明変数を適切に設定していくことは極めて重要である．
</details>
:::


:::ref
<details>
<summary>`factor`型への変換のもう一つの方法</summary>
`factor`型への変換は`as.factor()`関数を用いて行うのが基本であるが，あくまで回帰分析の中で一時的に`factor`型に変えたいだけというのであれば，以下のように`lm()`に渡すモデル式の中で`factor()`関数を用いることもできる．
```{r}
data <- read.csv("./practice/example_11_Dammy2.csv")
fit_edu <- lm(平均月収 ~ 性別 + factor(学歴) + 就労期間 + 残業時間, data = data)
summary(fit_edu)
```

ただ，もともとカテゴリカル変数であることはデータ読み込みの時点で分かっていることなので，データに含まれる各列の型をきちんと管理しておくためにも，データを読み込んだ時点で`factor`型に変換しておくことが望ましい．
</details>
:::

:::ref
<details>
<summary>factor型への変換を忘れた場合</summary>
factor型への変換を忘れてしまった場合でも，そのカテゴリカル変数が2値(0,1)なのであれば問題はないのだが，3値以上の場合には，そのカテゴリカル変数を数字でコード化していた場合には連続変数として扱われてしまう．
すなわち，先の例だと以下のようになる．
```{r}
data <- read.csv("./practice/example_11_Dammy2.csv")
fit_edu_wrong <- lm(平均月収 ~ 性別 + 学歴 + 就労期間 + 残業時間, data = data)
summary(fit_edu_wrong)
```
一見それらしい数値が出てきているが，これは学歴のコードとして振っている0,1,2を数値として扱っており，学歴を連続変数として扱った結果が出力されている．つまり，これは「学歴といて0.5という数字が**ありえて**，数値が0.5変化すると，月収が約2.4万円変わる」という結果を出力していることになる．当然，学歴に0.5などというものは概念として存在しない．したがって，このような処理は誤りとなる．

従って，3つ以上の水準を持つカテゴリカル変数を説明変数として回帰分析を行う場合には，その変数を`factor`型に変換しておくことが重要である．
</details>
:::

:::ref
<details>
<summary><a name="ダミー参考2">カテゴリカル変数のコードについて</a></summary>
先の例では，カテゴリカル変数のコードとして性別であれば0,1，学歴であれば0,1,2というように数字を割り振っていたが，Rでは必ずしもコードは数字である必要はない．

たとえば，以下の例は，性別を"男性"，"女性"，学歴を"高卒"，"大卒"，"院卒"という文字列でコード化している．
```{r}
data <- read.csv("./practice/example_11_Dammy2.csv")
data$性別 <- as.factor(ifelse(data$性別 == 1, "男性", "女性"))
data$学歴 <- as.factor(ifelse(data$学歴 == 0, "高卒", ifelse(data$学歴 == 1, "大卒", "院卒")))
fit_edu <- lm(平均月収 ~ 性別 + 学歴 + 就労期間 + 残業時間, data = data)
summary(fit_edu)
```

これの結果の見方として，性別については女性を基準にしていて，男性であった場合に約3.5万円高くなる．学歴については，院卒を基準にしていて，高卒であった場合に院卒に比べて約12.3円安くなり，大卒であった場合に9.4万円やすくなる，という見方をする．

特に学歴については一見すると先ほどと結果が異なるように見えるが，先ほどは学歴のコードが0，すなわち高卒を基準にしていて，大卒は高卒に比べて2.9万円($=12.3-9.4$)高くなり，院卒は高卒に比べて12.3万円高くなるという記述になっおり，基準にしているものが異なっているだけで内容は同じである．

このようにカテゴリカル変数に与える値は別に数値でなくても良いので，各自で使いやすいようなコードを与えておけばよい．なお，与えた値が文字列型(1文字でもOK)の場合，factor型に変換してなくても`lm()`関数の処理の中で自動的にfactor型に変換してくれる．ただ，先ほども書いたように自身のデータの整理・管理の面からカテゴリカル変数なのであればfactor型に変換しておく方が良い.（例えばデータにsummary()関数を掛けた場合の結果が異なってくる[参考](./RText_04_DescriptiveStatistics.html#summary()関数)）．

</details>
:::

## ダミー変数の有意性
ダミー変数の回帰係数は**その時の分析で基準となっている水準との差**であり，有意性は**基準となっている水準との差が有意かどうか**を示している．従て，上記の[参考](#ダミー参考2)内で示しているように基準の取り方が変わると，見た目上の係数やその有意確率が変わる． 

こうしたことから，例えばカテゴリ変数における各水準間の差の有意性をすべて評価するためには，基準を変えて分析を繰り返すことが必要である．ただしその場合には検定の多重性の問題が生じるため，有意確率の補正を行う必要がある（[参考](Rtext_07_BasicTest.html#多重比較)）．


## 分散分析への変換
回帰分析の結果から直接得られるのは各水準を表すダミー変数の回帰係数と有意確率であって，「カテゴリカル変数を考慮すること」そのものが有意な効果を持つかどうかを評価するわけではない．カテゴリカル変数を加えることが有意な効果を持つかどうかを評価したい場合には，通常は[分散分析](./RText_08_Anova.html)を行う．ただ，冒頭で述べた通りRでは回帰分析も分散分析も同じ枠組みの中で行っており，回帰分析の結果を分散分析の結果に変換することができる．


そのためには，`car`パッケージの`Anova()`関数を用いる．
`Anova()`関数は[二要因分散分析（交互作用なし）](./RText_08_Anova.html#一要因分散分析（対応あり）／交互作用のない二要因分散分析）)で用いたが，実は第1引数に与えるオブジェクトは`aov()`の結果のオブジェクトだけでなく，`lm()`の結果のオブジェクトも受け付ける．
使い方は全く同じで，第1引数に`lm()`の結果のオブジェクトを，第2引数に`type=2`を与える．
```{r}
library(car)
Anova(fit_edu, type = 2)
```
この結果から，学歴は平均月収に対して有意な効果を持つことが分かる．

比較のため，分散分析でも実施してみる．
```{r}
fit_anova <- aov(平均月収 ~ 性別 + 学歴 + 就労期間 + 残業時間, data = data)
Anova(fit_anova, type = 2)
```
全く同じ結果であることがわかる．



# 交互作用を含む回帰分析

分散分析では交互作用を含んだ分析について触れたが，回帰分析においても交互作用を含んだ分析を行うことができる．

実施方法は極めて簡単で，分散分析での交互作用と同じように`:`あるいは`*`を用いて，交互作用項を含んだモデル式を作成して，`lm()`関数に投入すればよい．



:::practice
[このデータ](./practice/example_11_Interaction.csv)は，ある会社での従業員のモチベーション（M），スキルレベル（S），業績（P）をそれぞれ評価したものである．モチベーションとスキルレベルが業績にどのような影響力持っているかを調べよ．

```{r include=FALSE}
set.seed(435)
# サンプルサイズ
n <- 150
# モチベーション 1~7までで小数第1位まで
motivation <- round(runif(n, min = 1, max = 7),1)

# スキルレベル 33~100までで整数
skill <- round(runif(n, min = 33, max = 100),0)

# 業績
performance <- round(50+5*(1.2*scale(motivation) + scale(skill) - 1.2 * scale(motivation*skill) + 1.1*rnorm(n, mean = 0, sd = 1)) ,0)

# データフレームを作成
data <- data.frame(
  M = motivation,
  S = skill,
  P = performance
)

#データフレームのCSVへの書き込み
write.csv(data, file = "./practice/example_11_Interaction.csv", row.names = FALSE)
summary(data)
```
:::

<!-- 今回は単純な予測式を立てることが目的ではなく，影響力を評価することが目的であるため，[標準化](./RText_10_Regression.html#標準化回帰係数)を行ったうえで回帰分析を行う． -->

```{r}
data <- read.csv("./practice/example_11_Interaction.csv")
# 標準化．
# data.scaled <- scale(data) 
# #scale()関数の出力は名前付き行列であってdata.frameではないのでdata.frameに変換
# data.scaled <- as.data.frame(data.scaled)
#標準化重回帰分析
fit_interaction <- lm(P ~ S + M  + S:M, data)
summary(fit_interaction)

```
この結果から，モチベーション，スキルのそれぞれが主効果として業績に有意な影響を与えるとともに，これらの交互作用も有意であることが分かる．

式に表すと，以下の通りとなる．
$$
P =  32.10+0.21 \times S + 2.86 \times M  -0.031  \times S \times M 
$$
この結果から，スキルの評価が1点上がるごとに業績は0.21点上がり，モチベーションが1点上がるごとに業績は2.86点上がる．

では，さらに，スキルとモチベーションの交互作用項はどのように解釈すればよいだろか．


## 回帰分析における交互作用の意味

分散分析での交互作用は，カテゴリカル変数である二つの変数（要因）の相乗効果，すなわち，単純にそれぞれが単独で目的変数に対して持つ影響力の足し合わせでは説明できない，組み合わさった場合にのみ現れる新たに生じてきた影響であると解釈される．

例えば，小麦の収穫量を目的変数として，XとYという効用の異なる二つの肥料を使うケースを考えてみよう．Xだけを使ったときには使わなかったときに比べ$\varDelta X$増え，Yだけを使ったときには同様に$\varDelta Y$増えるのであれば，XとYを両方使えば収穫量は$\varDelta X + \varDelta Y$増えるだろう，と予想するのが単純な影響力の足し合わせである．しかし，実際にはXとYを組み合わせて使うと，単純な足し合わせよりも収穫量が下がってしまうことはよくある．こうした「組み合わせ」によって生じる効果が交互作用である．
この例では，交互作用として目的変数に対してマイナスに作用する効果が現れる例だが，もちろんプラスに作用する効果もある．



では，回帰分析での交互作用とはどういうものだろうか．
回帰分析での交互作用においては，**一方が持つ説明変数の目的変数に対する影響力が，他方の説明変数によって変わる**という解釈がなされる．

先ほどの例で具体的に説明しよう．先ほど示した業績の式は以下のように変形できる．

$$
\begin{align}
P &= 32.10+0.21 \times S + 2.86 \times M  -0.031  \times S \times M \\
&= 32.10+0.21 \times S + (2.86   -0.031  \times S) \times M \\
\end{align}
$$
このように式変形すると，Mの係数がSの値によって変わることがわかる．すなわち，スキルレベルSが1点上がるごとにモチベーションMの係数が0.031だけ下がる．逆にスキルレベルSが1点下がるごとにモチベーションMの係数が0.031だけ上がる．

具体的に，Mをx軸，Pをy軸として，Sを1標準偏差上げた場合と1標準偏差下げた場合のグラフを書いてみると以下の通りとなる．

```{r}
library(ggplot2)
m_S <- mean(data$S)
sd_S <- sd(data$S)
ggplot(data, aes(x = M, y = P)) + 
  geom_abline(aes(
    intercept = coef(fit_interaction)["(Intercept)"]+coef(fit_interaction)["S"]*(m_S),
    slope = coef(fit_interaction)["M"]+coef(fit_interaction)["S:M"]*(m_S), 
    color = "S:Mean")) +
  geom_abline(aes(
    intercept = coef(fit_interaction)["(Intercept)"]+coef(fit_interaction)["S"]*(m_S+sd_S),
    slope = coef(fit_interaction)["M"]+coef(fit_interaction)["S:M"]*(m_S+sd_S), 
    color = "S:+1SD")) +
  geom_abline(aes(
    intercept = coef(fit_interaction)["(Intercept)"]+coef(fit_interaction)["S"]*(m_S-sd_S),
    slope = coef(fit_interaction)["M"]+coef(fit_interaction)["S:M"]*(m_S-sd_S), 
    color = "S:-1SD")) +
  scale_x_continuous(limits = c(1, 7)) +
  scale_y_continuous(limits = c(40, 60)) +
  scale_color_manual(values = c("S:Mean" = "black","S:+1SD" = "blue", "S:-1SD" = "red")) +
  labs(color = "凡例")   # 凡例のタイトル

  

```



このグラフから，スキルレベルが高い人たちの場合，モチベーションは業績にそれほど強く影響を与えない（傾きが小さい）が，スキルレベルが低い人たちの場合，モチベーションは業績に強く影響を与える（傾きが大きい），ということが分かる．

このように，回帰分析における交互作用は，一方の説明変数が持つ影響力が他方の説明変数によって変わるという解釈がなされる．

## 単純傾斜分析

分散分析で交互作用が有意であった場合に下位検定として[単純傾斜分析](./RText_08_Anova.html#下位検定（単純主効果検定）)を行っていた．すなわち，一方の要因の水準ごとに，他方の要因の水準間での目的変数の差を検定することを行うことを行った．

これと同様のことを行うのが単純傾斜分析（Simple Slope Analysis）である．回帰分析において交互作用が有意であった場合に，一方の説明変数を$\pm 1$標準偏差だけ変化させた場合の他方の説明変数の回帰係数が有意になるかどうかを検討するものである．

単純傾斜分析は`interactions`パッケージを用いることで簡単に行うことができる．

```{r}
library(interactions)
simple_slope_results <- sim_slopes(fit_interaction, pred= M, modx = S,confint = TRUE)
print(simple_slope_results)
interact_plot(fit_interaction, pred= M, modx = S)
```
この結果から，スキルレベルSが1標準偏差上昇した場合，モチベーションMが業績Pに与える影響は有意であることが分かる．逆にスキルレベルSが1標準偏差下降した場合，モチベーションMが業績Pに与える影響は有意であることが分かる．


:::ref
<details>
<summary>単純傾斜分析のマニュアル実行</summary>
単純傾斜分析は`interactions`パッケージを用いずに，`lm()`関数だけで行うこともできる．
方法としては，標準偏差を動かしたい変数に対して，1を足す，もしくは1を引く処理を行ったデータを用意して，`lm()`に与えればよいだけである．
```{r}
#Sを1標準偏差足す
data_p <-data
data_p$S <- data_p$S+1*sd(data$S)
fit_p<-lm(P ~ S + M + S:M, data_p)
summary(fit_p)

#Sを1標準偏差引く
data_m <-data
data_m$S <- data_m$S-1*sd(data$S)
fit_m<-lm(P ~ S + M + S:M, data_m)
summary(fit_m)

```

</details>
# カテゴリカル変数を含んだ回帰分析のイメージ


# 回帰分析でカテゴリカル変数を扱うメリット

以上，回帰分析でもカテゴリカル変数を扱えること，また，回帰分析の結果は分散分析の結果に変換できることを示した．

回帰分析でカテゴリカル変数を扱うことのメリットとして，回帰分析と分散分析を使い分ける必要がなくなる，という手続き上のメリットが挙げられるが，それより重要な点として，**カテゴリカル変数を統制変数として投入することによって，その他の連続変数の回帰係数の推定の精度が上がることが挙げられる**．[参考](#カテゴリカル変数を含んだ回帰分析のイメージ)内でも述べたとおり，カテゴリカル変数を導入することによって，本来はカテゴリカル変数によって説明すべきものがきちんとカテゴリカル変数によって説明されるようになり，これによって他の説明変数はより純粋にその説明変数で説明すべきものが説明されるようになる．

このように，カテゴリカル変数を含む回帰分析は，カテゴリカル変数の効果を推定するだけでなく，他の説明変数の効果をより正確に推定するための手法としても有用である．